---
import DGGetAccessor from "./Accessor/DGGetAccessor.astro";
import DGSetAccessor from "./Accessor/DGSetAccessor.astro";
import TypeClassDeclaration from "./Declaration/TypeClassDeclaration.astro";
import TypeEnumDeclaration from "./Declaration/TypeEnumDeclaration.astro";
import TypeFunctionDeclaration from "./Declaration/TypeFunctionDeclaration.astro";
import TypeInterfaceDeclaration from "./Declaration/TypeInterfaceDeclaration.astro";
import TypeMethodDeclaration from "./Declaration/TypeMethodDeclaration.astro";
import TypePropertyDeclaration from "./Declaration/TypePropertyDeclaration.astro";
import TypeTypeAliasDeclaration from "./Declaration/TypeTypeAliasDeclaration.astro";
import TypeAnyKeyword from "./Keywords/TypeAnyKeyword.astro";
import TypeBooleanKeyword from "./Keywords/TypeBooleanKeyword.astro";
import TypeNullKeyword from "./Keywords/TypeNullKeyword.astro";
import TypeNumberKeyword from "./Keywords/TypeNumberKeyword.astro";
import TypeStringKeyword from "./Keywords/TypeStringKeyword.astro";
import TypeVoidKeyword from "./Keywords/TypeVoidKeyword.astro";
import EnumMember from "./Other/EnumMember.astro";
import ParenthesizedType from "./Other/ParenthesizedType.astro";
import TypeStringLiteral from "./Other/TypeStringLiteral.astro";
import TypeTypeReference from "./References/TypeTypeReference.astro";
import TypeMethodSignature from "./Signatures/TypeMethodSignature.astro";
import TypePropertySignature from "./Signatures/TypePropertySignature.astro";
import DGConditionalType from "./Types/DGConditionalType.astro";
import DGMappedType from "./Types/DGMappedType.astro";
import TypeArrayType from "./Types/TypeArrayType.astro";
import TypeFunctionType from "./Types/TypeFunctionType.astro";
import TypeIndexedAccessType from "./Types/TypeIndexedAccessType.astro";
import TypeIntersectionType from "./Types/TypeIntersectionType.astro";
import TypeLiteralType from "./Types/TypeLiteralType.astro";
import TypeRestType from "./Types/TypeRestType.astro";
import TypeTupleType from "./Types/TypeTupleType.astro";
import TypeUnionType from "./Types/TypeUnionType.astro";
import DGTypeOperator from "./Other/DGTypeOperator.astro";
import DGNeverKeyword from "./Keywords/DGNeverKeyword.astro";
import DGUndefinedKeyword from "./Keywords/DGUndefinedKeyword.astro";
import DGTypeQuery from "./Other/DGTypeQuery.astro";

type Props = {
    data: any;
    depth: number;
};

const { data, depth } = Astro.props;
const kind = data?.kind;
---

{
    () => {
        if (!kind) return "";

        switch (kind) {
            // Declarations
            case "InterfaceDeclaration":
                return <TypeInterfaceDeclaration data={data} depth={depth} />;
            case "ClassDeclaration":
                return <TypeClassDeclaration data={data} depth={depth} />;
            case "PropertyDeclaration":
                return <TypePropertyDeclaration data={data} depth={depth} />;
            case "MethodDeclaration":
                return <TypeMethodDeclaration data={data} depth={depth} />;
            case "EnumDeclaration":
                return <TypeEnumDeclaration data={data} depth={depth} />;
            case "TypeAliasDeclaration":
                return <TypeTypeAliasDeclaration data={data} depth={depth} />;
            case "FunctionDeclaration":
                return <TypeFunctionDeclaration data={data} depth={depth} />;

            // References
            case "TypeReference":
                return <TypeTypeReference data={data} depth={depth} />;

            // Types
            case "FunctionType":
                return <TypeFunctionType data={data} depth={depth} />;
            case "ArrayType":
                return <TypeArrayType data={data} depth={depth} />;
            case "TupleType":
                return <TypeTupleType data={data} depth={depth} />;
            case "RestType":
                return <TypeRestType data={data} depth={depth} />;
            case "UnionType":
                return <TypeUnionType data={data} depth={depth} />;
            case "IntersectionType":
                return <TypeIntersectionType data={data} depth={depth} />;
            case "LiteralType":
                return <TypeLiteralType data={data} depth={depth} />;
            case "IndexedAccessType":
                return <TypeIndexedAccessType data={data} depth={depth} />;
            case "MappedType":
                return <DGMappedType data={data} depth={depth} />;
            case "ConditionalType":
                return <DGConditionalType data={data} depth={depth} />;

            // Accessors
            case "SetAccessor":
                return <DGSetAccessor data={data} depth={depth} />;
            case "GetAccessor":
                return <DGGetAccessor data={data} depth={depth} />;

            // Others
            case "StringLiteral":
                return <TypeStringLiteral data={data} depth={depth} />;
            case "TypeOperator":
                return <DGTypeOperator data={data} depth={depth} />;
            case "TypeQuery":
                return <DGTypeQuery data={data} depth={depth} />;

            // Keywords
            case "StringKeyword":
                return <TypeStringKeyword data={data} depth={depth} />;
            case "BooleanKeyword":
                return <TypeBooleanKeyword data={data} depth={depth} />;
            case "NumberKeyword":
                return <TypeNumberKeyword data={data} depth={depth} />;
            case "VoidKeyword":
                return <TypeVoidKeyword data={data} depth={depth} />;
            case "NullKeyword":
                return <TypeNullKeyword data={data} depth={depth} />;
            case "AnyKeyword":
                return <TypeAnyKeyword data={data} depth={depth} />;
            case "NeverKeyword":
                return <DGNeverKeyword data={data} depth={depth} />;
            case "UndefinedKeyword":
                return <DGUndefinedKeyword data={data} depth={depth} />;

            // Signatures
            case "PropertySignature":
                return <TypePropertySignature data={data} depth={depth} />;
            case "MethodSignature":
                return <TypeMethodSignature data={data} depth={depth} />;

            // Members
            case "EnumMember":
                return <EnumMember data={data} depth={depth} />;

            case "ParenthesizedType":
                return <ParenthesizedType data={data} depth={depth} />;

            // Fallback
            default:
                return (
                    <div class="bg-base-300 p-4 my-2">
                        Parsing error with <span class="text-warning">{kind}</span>
                    </div>
                );
        }
    }
}
