---
title: Migrating to v4000
description: Migrate your codebase to v4000.
url: migration-4000
order: "misc-2"
version: "4000"
---

import Info from "@/components/Content/Info.astro";

# v3001 to v4000 Migration

Update KAPLAY library like this:

```sh
npm install kaplay@next
```

Then follow along. Not everything mentioned below will affect your game. We are
listing everything that got removed, renamed, changed, and some of the [upcoming
changes](#upcoming-changes) at the very end.

---

## Removed: `make()`

`make()` is an internal function that KAPLAY uses for creating the `GameObjRaw`
interface without adding it to the tree. If you were using it, it was for one
of these two reasons:

1. Using it for "modifying" the object before its "creation", can be updated
   like this:

```js
// BEFORE
const obj = make([sprite("bean")]);

obj.sprite = "mark";

add(obj);
```

```js
// AFTER
const makeObj = () => [sprite("bean")];

const obj = add([...makeObj(), sprite("mark")]);
```

```js
// Or literally, modifying an object on add()
const makeObj = () => [
    sprite("bean"),
    {
        add() {
            this.sprite = "mark";
        },
    },
];

const obj = add(makeObj());
```

2. Using it for prefab-like factory functions, can be updated like this:

```js
// BEFORE
const makeEnemy = (x = 100, y = 100) => {
    const obj = make([sprite("alien"), pos(x, y)]);

    return obj;
};

const enemy1 = add(makeEnemy()); // (100, 100)
const enemy2 = add(makeEnemy(400, 200)); // (400, 200)
```

```js
// AFTER
const makeEnemy = (x = 100, y = 100) => {
    return [sprite("alien"), pos(x, y)];
};

const enemy1 = add(makeEnemy()); // (100, 100)
const enemy2 = add(makeEnemy(400, 200)); // (400, 200)
```

Factory functions are the easiest drop-in replacement for `make()`. Besides
returning an array of objects, you can also call `add()` right inside and
return it. Learn more about
[Creating game object dynamically](/docs/guides/game_objects#creating-game-object-dynamically).

Or, create new objects by copying existing ones **using prefabs**:

```js
const enemy1 = add([sprite("alien"), pos(100)]); // (100, 100)

const enemyPrefab = createPrefab("enemy", enemy);

const enemy2 = addPrefab("enemy", [pos(400, 200)]); // (400, 200)
```

Prefabs can also load serialized objects and a lot more! Check the
[Prefab guide](/docs/guides/prefabs) for more information.

---

## Changed: Component IDs are no longer tags

Before, used components would add their IDs as tags along the user definded tags.
This behavior could cause some collisions or unexpected results.

There was a new API introduced to keep the original usability. You can either
update your code, or revert this behavior.

1. Replace every use of `obj.is()` when checking for component presence, to
   `obj.has()`:

```js
// BEFORE
obj.is("sprite");
```

```js
// AFTER
obj.has("sprite");
```

Also, obviously the `obj.tags` array won't include the component IDs either.
You will need a custom query to get e.g. all objects with a sprite component:

```js
get("*", { recursive: true }).filter((obj) => obj.has("sprite"));
```

Similar will happen with `obj.onTag()` and `obj.onUntag()`. Those won't be
triggered for component IDs. Use `obj.onUse()` and `obj.onUnuse()` in place of
those:

```js
// BEFORE
obj.onTag("sprite", () => debug.log("sprite comp added"));
obj.onUntag("sprite", () => debug.log("sprite comp removed"));
```

```js
// AFTER
obj.onUse("sprite", () => debug.log("sprite comp added"));
obj.onUnuse("sprite", () => debug.log("sprite comp removed"));
```

Or alternatively, you can add them as tags manually where needed (e.g.
`"sprite"`) if it makes sense to you. More in [Tags guide](/docs/guides/tags/).

2. If you have much more complicated use case, you can revert it to the original
   behavior with `tagComponentIds` KAPLAY Option:

```js
kaplay({
    tagComponentIds: true,
});
```

## Changed: Global z-index sorting

Objects using `z()` component are now sorted globally, meaning any child can be
drawn above any parent siblings, or any object (within the same `layer()` if used).

Previously, children of objects using `z()` would inherit the drawing order and
its scope, so they could not escape and draw in order higher than the parent
itself, or lower for that matter (behind the parent).

**If you are using `z()` on children objects, you might run into an issue that
children of one object are now drawn above the other object siblings despite
the first parent being drawn first/lower.**

You will have to solve it by setting higher `z()` for parent objects as well as
needed, or start using `layer()` more regularly. Objects of a layer below another
layer still can't be drawn above the higher order layer as they are creating a
separate stacking context. This will vary from case to case depending on your
game, so there is not an ultimate solution. You can get more help on our
[Discord](https://discord.com/invite/aQ6RuQm3TF) with your use case.

You can also try to ensure the order of components/children drawn/added if
possible and skip z-sorting altogether. Suitable for simple cases like this:

```js
// Within the same object, yellow rect will be behind the text
const marker = add([
    {
        draw() {
            drawRect({
                width: this.width,
                height: this.height,
                color: YELLOW,
            });
        },
    },
    text("Ohhi!"),
    color(BLACK),
]);
```

For more complex objects, you could still create an "empty" wrapping parent
object with children added in the right order as well.

## Changed: GJK is now the default collision algorithm replacing SAT

GJK (Gilbert-Johnson-Keerthi) is faster and more versatile algorithm allowing
any shapes unlike SAT (Separating Axis Theorem). This allows the use of circle
and ellipse as collision shapes.

If you are noticing the change of behavior in collisions, this might be the
reason. Especially for free roaming objects on level based platformers (depending
on how implemented).

If it affects you and you don't know how to mitigate it, you can revert it to
the previous SAT algorithm with this KAPLAY option:

```js
kaplay({
    narrowPhaseCollisionAlgorithm: "sat",
});
```

---

## Upcoming changes

<Info crew="github" title="Important!">
    Following changes are based on `master` KAPLAY version (the one that matches the last GitHub commit). It can be installed with `npm i
    github:kaplayjs/kaplay`
</Info>

### Renamed: Global events (WIP)

<span class="head-badge">Not implemented yet</span>

`onShow()` `→` `onTabShow()`

`onHide()` `→` `onTabHide()`

`onResize()` `→` `onTabResize()`
